This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
activities/
  2025-05-03/
    age-chart.md
    cheatsheet.md
    homework.md
    multiplication-table.md
  2025-05-17/
    chessboard.md
    homework.md
    spiraling-octagon.md
    stars-in-the-sky.md
.gitignore
readme.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="activities/2025-05-17/chessboard.md">
# Python Homework: Turtle Graphics - Drawing a Chessboard

Follow the steps below. For each step:
1.  **Read the problem carefully.**
2.  **Try to write the Python code yourself in VS Code.**
3.  **If you get stuck, open the "Hint" section.**
4.  **Once you think you have a solution or want to check your work, open the "Solution" section.**
5.  **Make sure your code works by running it!**

---

## Initial Setup

For all steps in this homework, you'll start with the following basic Python code. Make sure you have this at the beginning of your Python file. You'll add your drawing code for each step where indicated.

```python
import turtle

s = turtle.Screen()
t = turtle.Turtle()

turtle.tracer(0, 0) # Turns off screen updates for instant drawing

# Initial turtle settings
t.speed(0) # Set turtle speed to fastest (0 is fastest)
t.penup()
# Set a starting position, for example, towards the bottom-left
# An 8x8 board with 60px squares will be 480x480.
# (-300, -300) is a point from where we can draw towards top-right.
t.goto(-300, -300)
t.pendown()

# Define constants for the board
square_size = 60
board_size = 8 # We'll be making an 8x8 board

# Your drawing code for each step will go here

turtle.done() # Keeps the turtle window open until you close it
```
Remember to place the code for each step *before* the `turtle.done()` line. The `turtle.tracer(0,0)` command means the drawing will appear instantly once all commands are processed.

---

## Step 1: Drawing a Row of Black Squares

### Problem

Your first task is to make the turtle draw a single horizontal row of 8 black, filled squares. Each square should be `square_size` in dimension. After drawing each square, the turtle should move to the starting position of the next square in the row.

### Hint

<details>
  <summary>Stuck on Step 1? Click for a hint!</summary>

  *   You'll need a `for` loop that repeats `board_size` (which is 8) times.
  *   Inside the loop, you need to draw one filled square:
      *   Start filling using `t.begin_fill()`.
      *   Draw the four sides of the square: `t.forward(square_size)` and `t.left(90)` repeated 4 times (perhaps using another loop).
      *   End filling using `t.end_fill()`.
  *   After drawing and filling one square, you need to move the turtle to the start of the next square in the same row. This means moving `t.forward(square_size)` *without* turning.
  *   Ensure the fill color is black. You can set this once using `t.fillcolor("black")` before the loop, or ensure the default is black.

</details>

### Solution

<details>
  <summary>Ready to check your answer for Step 1? Click to reveal!</summary>

```python
import turtle

s = turtle.Screen()
t = turtle.Turtle()

turtle.tracer(0, 0)

t.speed(0)
t.penup()
t.goto(-300, -300)
t.pendown()

square_size = 60
board_size = 8

# Set fill color to black for all squares in this step
t.fillcolor("black")

for i in range(board_size):
    # Draw one filled square
    t.begin_fill()
    for k in range(4): # A square has 4 sides
        t.forward(square_size)
        t.left(90)
    t.end_fill()

    # Move to the start of the next square in the row
    t.forward(square_size)

turtle.done()
```

**Explanation:**
*   The initial setup prepares the turtle.
*   `t.fillcolor("black")` sets the fill color for the squares.
*   The outer `for i in range(board_size):` loop iterates 8 times, once for each square in the row.
*   Inside this loop:
    *   `t.begin_fill()` starts the fill process.
    *   The inner `for k in range(4):` loop draws the 4 sides of a square.
    *   `t.end_fill()` completes the fill for the current square.
    *   `t.forward(square_size)` moves the turtle to the right, ready to draw the next square adjacent to the current one.

</details>

---

## Step 2: Alternating Colors in a Row

### Problem

Modify your code from Step 1. Instead of all black squares, make the squares in the row alternate colors: the first black, the second white, the third black, and so on, for all 8 squares in the row.

### Hint

<details>
  <summary>Stuck on Step 2? Click for a hint!</summary>

  *   Inside your main loop (that iterates `board_size` times), you need to decide the `t.fillcolor()` *before* `t.begin_fill()`.
  *   Use an `if/else` statement to choose between `'black'` and `'white'`.
  *   The loop variable (e.g., `i`) can help you decide. The modulo operator (`%`) is useful here. `i % 2 == 0` is true if `i` is even (0, 2, 4...).
  *   If `i` is even, set one color; if `i` is odd, set the other color.

</details>

### Solution

<details>
  <summary>Ready to check your answer for Step 2? Click to reveal!</summary>

```python
import turtle

s = turtle.Screen()
t = turtle.Turtle()

turtle.tracer(0, 0)

t.speed(0)
t.penup()
t.goto(-300, -300)
t.pendown()

square_size = 60
board_size = 8

for i in range(board_size):
    # Determine fill color based on loop index 'i'
    if i % 2 == 0: # Even index (0, 2, 4...)
        t.fillcolor('black')
    else: # Odd index (1, 3, 5...)
        t.fillcolor('white')

    # Draw one filled square
    t.begin_fill()
    for k in range(4):
        t.forward(square_size)
        t.left(90)
    t.end_fill()

    # Move to the start of the next square
    t.forward(square_size)

turtle.done()
```

**Explanation:**
*   The key change is inside the loop for the row.
*   `if i % 2 == 0:` checks if the current square's index `i` is even.
    *   If it's even (0, 2, ...), `t.fillcolor('black')` is set.
    *   Else (if `i` is odd), `t.fillcolor('white')` is set.
*   The rest of the square drawing logic and movement remains the same. This creates a row with alternating black and white squares.

</details>

---

## Step 3: Drawing the Full Grid (Basic Chessboard Structure)

### Problem

Now, expand your single row of alternating colored squares into a full 8x8 grid. You'll need to draw 8 rows, and each row should be like the one you created in Step 2.
After drawing each row, the turtle needs to move to the beginning of the next row, which will be positioned directly above the row just completed.

For this step, the coloring might not be a perfect chessboard yet (e.g., all rows might start with black). We'll fix the precise chessboard pattern in the next step.

### Hint

<details>
  <summary>Stuck on Step 3? Click for a hint!</summary>

  *   You'll need *nested* `for` loops. An outer loop for the rows (iterating `board_size` times) and an inner loop for the squares within each row (also iterating `board_size` times).
  *   The inner loop will contain the logic from Step 2 for drawing one row with alternating colors. Let the outer loop variable be `i` (for rows) and the inner loop variable be `j` (for columns/squares in a row).
  *   The color alternation logic from Step 2 (`if j % 2 == 0: ... else: ...`) should now use the *inner loop variable* (`j`) to alternate colors within a row.
  *   **Crucially**, after the inner loop finishes (i.e., one row is drawn), you must:
      1.  Lift the pen: `t.penup()`.
      2.  Move the turtle back to the horizontal starting position of the row. This means moving backward by `square_size * board_size`.
      3.  Move the turtle up to the starting vertical position of the next row. A common way is: `t.left(90)`, `t.forward(square_size)`, `t.right(90)`. This sequence moves the turtle "up" by `square_size` while keeping its heading to the right.
      4.  Put the pen down: `t.pendown()`.

</details>

### Solution

<details>
  <summary>Ready to check your answer for Step 3? Click to reveal!</summary>

```python
import turtle

s = turtle.Screen()
t = turtle.Turtle()

turtle.tracer(0, 0)

t.speed(0)
t.penup()
t.goto(-300, -300)
t.pendown()

square_size = 60
board_size = 8

# Outer loop for rows
for i in range(board_size):
    # Inner loop for squares in a row (columns)
    for j in range(board_size):
        # Color determination based on column index 'j' for this step
        if j % 2 == 0:
            t.fillcolor('black')
        else:
            t.fillcolor('white')

        t.begin_fill()
        for k in range(4): # Draw one square
            t.forward(square_size)
            t.left(90)
        t.end_fill()

        t.forward(square_size) # Move to next square position in the row

    # After finishing a row, move to the start of the next row
    t.penup()
    t.backward(square_size * board_size) # Go back to the row's starting X
    t.left(90)                           # Turn to face upwards
    t.forward(square_size)               # Move up by one square_size
    t.right(90)                          # Turn back to face right
    t.pendown()

turtle.done()
```

**Explanation:**
*   An outer loop `for i in range(board_size):` controls the rows.
*   An inner loop `for j in range(board_size):` controls the columns (squares within each row).
*   The color logic `if j % 2 == 0:` makes each row alternate starting with black (as `j` resets for each row).
*   The critical part is after the inner loop completes:
    *   `t.penup()`
    *   `t.backward(square_size * board_size)`: Moves the turtle to the left edge of the board for the current row.
    *   `t.left(90)`, `t.forward(square_size)`, `t.right(90)`: This sequence moves the turtle up by one square's height to begin the next row, while maintaining its orientation to draw squares to the right.
    *   `t.pendown()`

</details>

---

## Step 4: Achieving True Chessboard Colors

### Problem

Modify your code from Step 3 to create the correct alternating color pattern for a chessboard. On a chessboard, if a square at `(row, col)` is black, then its neighbors `(row+1, col)` and `(row, col+1)` are white.

The color of a square now depends on both its row index (`i`) and its column index (`j`).

### Hint

<details>
  <summary>Stuck on Step 4? Click for a hint!</summary>

  *   The `if/else` condition for `t.fillcolor()` needs to consider both the row index (`i` from the outer loop) and the column index (`j` from the inner loop).
  *   One common way: If the sum of the row and column indices (`i + j`) is even, the square is one color (e.g., black). If the sum is odd, it's the other color (e.g., white). So, check `(i + j) % 2 == 0`.
  *   Alternatively, a more explicit condition: A square is one color if (`i` is even AND `j` is even) OR (`i` is odd AND `j` is odd). Otherwise, it's the other color. This can be written as: `(i % 2 == 0 and j % 2 == 0) or (i % 2 != 0 and j % 2 != 0)`.

</details>

### Solution

<details>
  <summary>Ready to check your answer for Step 4? Click to reveal!</summary>

```python
import turtle

s = turtle.Screen()
t = turtle.Turtle()

turtle.tracer(0, 0)

t.speed(0)
t.penup()
t.goto(-300, -300)
t.pendown()

square_size = 60
board_size = 8

# Outer loop for rows
for i in range(board_size):
    # Inner loop for squares in a row (columns)
    for j in range(board_size):
        # Determine color based on both row (i) and column (j)
        # If (i is even AND j is even) OR (i is odd AND j is odd), color it black
        # This is one way to get the chessboard pattern.
        if (i % 2 == 0 and j % 2 == 0) or \
           (i % 2 != 0 and j % 2 != 0):
            t.fillcolor('black')
        else:
            t.fillcolor('white')
        
        # Alternative (often simpler) condition:
        # if (i + j) % 2 == 0:
        #    t.fillcolor('black')
        # else:
        #    t.fillcolor('white')

        t.begin_fill()
        for k in range(4): # Draw one square
            t.forward(square_size)
            t.left(90)
        t.end_fill()

        t.forward(square_size) # Move to next square position in the row

    # After finishing a row, move to the start of the next row
    t.penup()
    t.backward(square_size * board_size)
    t.left(90)
    t.forward(square_size)
    t.right(90)
    t.pendown()

turtle.done()
```

**Alternative (more compact) Solution for color logic:**
The solution above includes a common way to determine chessboard colors. A more mathematically concise way is to check the parity of the sum of the indices:

```python
# Inside the nested loops (replace the if/else block for fillcolor):
if (i + j) % 2 == 0:
    t.fillcolor('black') # Or your desired starting color for (0,0)
else:
    t.fillcolor('white')
```
If your (0,0) square (bottom-left if you draw bottom-up) needs to be white, you might swap the colors or use `(i + j) % 2 != 0` for black.

**Explanation:**
*   The main structure is the same as Step 3.
*   The crucial change is the condition for `t.fillcolor()`. It now uses both `i` (row index) and `j` (column index).
*   The condition `(i % 2 == 0 and j % 2 == 0) or (i % 2 != 0 and j % 2 != 0)` means:
    *   If both `i` and `j` are even, the square is black.
    *   If both `i` and `j` are odd, the square is black.
    *   Otherwise (one is even and one is odd), the square is white.
    This creates the classic chessboard pattern.
*   The alternative `if (i + j) % 2 == 0:` condition is simpler and achieves the same result. If the sum of indices is even, it's one color; if odd, it's the other. This naturally creates the alternating pattern across rows and columns.

</details>

---

## You Finished!

Congratulations on drawing a chessboard! You've practiced:
*   Importing and using the `turtle` module.
*   Setting up the `Screen` and `Turtle` objects.
*   Using `turtle.tracer(0,0)` for instant drawing.
*   Moving the turtle with `t.penup()`, `t.pendown()`, `t.goto()`, `t.forward()`, `t.backward()`, and `t.left()`/`t.right()`.
*   Drawing filled shapes using `t.begin_fill()`, `t.end_fill()`, and `t.fillcolor()`.
*   Using `for` loops to repeat actions.
*   Using **nested `for` loops** to create grid-like structures.
*   Using `if/else` statements for conditional logic (choosing colors).
*   Using the **modulo operator (`%`)** to determine even/odd numbers for alternating patterns.
*   Combining row and column indices to create complex patterns like a chessboard.
*   Resetting the turtle's position to draw successive rows in a grid.
*   Keeping the turtle graphics window open using `turtle.done()`.
</file>

<file path="activities/2025-05-17/homework.md">
I've prepared three problems for you. Do them in the following order:

1. [Spiraling Octagon](./spiraing-octagon.md)
2. [Stars in the Sky](./stars-in-the-sky.md)
3. [Chessboard](./chessboard.md)

Once all homework is done, you can see the cheatsheet containing concepts from the activities you've just done.

Good luck!
</file>

<file path="activities/2025-05-17/spiraling-octagon.md">
# Python Homework: Turtle Graphics and Loops

Follow the steps below. For each step:
1.  **Read the problem carefully.**
2.  **Try to write the Python code yourself in VS Code.**
3.  **If you get stuck, open the "Hint" section.**
4.  **Once you think you have a solution or want to check your work, open the "Solution" section.**
5.  **Make sure your code works by running it!**

---

## Initial Setup

For all steps in this homework, you'll start with the following basic Python code that uses the `turtle` library. Make sure you have this at the beginning of your Python file.

```python
import turtle

s = turtle.Screen()
t = turtle.Turtle()

t.speed(10) # Set turtle speed (0 is fastest, 10 is fast, 1 is slowest)
# Your drawing code will go here for each step

turtle.done() # Keeps the turtle window open until you close it
```
Remember to place the code for each step *before* the `turtle.done()` line.

---

## Step 1: Drawing a Repeated Square Path

### Problem

Your first task is to make the turtle draw a square. After drawing the first square, the turtle should continue and draw the same square path a total of 10 times. The turtle will trace over its own path.

Your turtle should start at its default position and orientation.

### Hint

<details>
  <summary>Stuck on Step 1? Click for a hint!</summary>

  *   To draw a single square, you need to move forward and turn left (or right) four times. What angle do you use for a square?
  *   To repeat this action 10 times, you'll need a `for` loop. The `range()` function will be helpful here.
  *   The commands `t.forward(amount)` and `t.left(angle)` will be essential. You can pick any reasonable `amount` for the side length of the square (e.g., 100).

</details>

### Solution

<details>
  <summary>Ready to check your answer for Step 1? Click to reveal!</summary>

```python
import turtle
import math

s = turtle.Screen()
t = turtle.Turtle()

t.speed(10)

# Loop 10 times for the 10 squares
for _ in range(10): # We use _ because we don't need the loop variable's value itself
    # Draw one square
    t.forward(100)
    t.left(90)
    t.forward(100)
    t.left(90)
    t.forward(100)
    t.left(90)
    t.forward(100)
    t.left(90)
    # After drawing one square, the turtle is back at the start, ready for the next iteration

turtle.done()
```

**Alternative (more compact) Solution for drawing one square inside the loop:**
```python
import turtle
import math

s = turtle.Screen()
t = turtle.Turtle()

t.speed(10)

# Loop 10 times for the 10 squares
for _ in range(10):
    # Draw one square using an inner loop
    for _ in range(4): # A square has 4 sides
        t.forward(100)
        t.left(90)

turtle.done()
```

**Explanation:**
*   `import turtle` loads the turtle graphics library.
*   `s = turtle.Screen()` creates the drawing window.
*   `t = turtle.Turtle()` creates our turtle object.
*   `t.speed(10)` sets the drawing speed.
*   The outer `for _ in range(10):` loop makes the turtle repeat the drawing process 10 times.
*   Inside this loop (in the more compact solution), another `for _ in range(4):` loop draws the four sides of a square.
*   `t.forward(100)` moves the turtle forward by 100 units.
*   `t.left(90)` turns the turtle left by 90 degrees.
*   `turtle.done()` keeps the window open.

</details>

---

## Step 2: Spiraling Out

### Problem

Modify your code from Step 1. Instead of drawing the same square 10 times in the same place, make the turtle draw a square spiral that grows outwards. Each side of the "square" in the spiral should get longer.

Start with a small side length for the first segment and increase it with each segment the turtle draws. You'll still be making 90-degree turns. Loop a chosen number of times (e.g., 40 times, which would be 10 "squares" if each square has 4 sides, or simply 40 segments).

The output should look like an expanding square spiral.

### Hint

<details>
  <summary>Stuck on Step 2? Click for a hint!</summary>

  *   You'll still use a `for` loop. Let the loop variable (e.g., `i`) increase with each iteration.
  *   The `t.forward()` command will need to use a distance that changes. How can you use the loop variable `i` to make the forward distance increase?
  *   Multiplying the loop variable by a small constant (e.g., `10 * i`) can be a good way to increase the distance for `t.forward()`.
  *   You'll still use `t.left(90)` for the turns.
  *   Think about how many turns/segments you want to draw in total. If you loop, say, 40 times, and each time you move forward and turn, you'll get 40 segments.

</details>

### Solution

<details>
  <summary>Ready to check your answer for Step 2? Click to reveal!</summary>

```python
import turtle
import math

s = turtle.Screen()
t = turtle.Turtle()

t.speed(10)

# We'll draw many segments to make a visible spiral
# Each iteration draws one side of the expanding "square"
for i in range(40): # For example, 40 segments
    # Make the forward distance increase with each step
    # Start with a small step and multiply by i
    t.forward(5 * i) # You can adjust the '5' to change how fast it spirals
    t.left(90)       # A 90-degree turn for a square-like spiral

turtle.done()
```

**Explanation:**
*   The setup is the same.
*   `for i in range(40):` loops 40 times. The variable `i` will go from 0 to 39.
*   `t.forward(5 * i)`: This is the key change.
    *   In the first iteration (`i=0`), `t.forward(0)` (turtle doesn't move).
    *   In the second iteration (`i=1`), `t.forward(5)`.
    *   In the third iteration (`i=2`), `t.forward(10)`, and so on.
    *   This makes each segment the turtle draws longer than the last, causing it to spiral outwards.
*   `t.left(90)` keeps the turns at 90 degrees, maintaining the square-like nature of the spiral.

</details>

---

## Step 3: Making it Jagged (Spiraling with Angle Change)

### Problem

Now, modify your spiraling code from Step 2. Keep the outward spiraling movement (increasing forward distance). However, slightly change the angle of the turn in each step. This will make the spiral look more "jagged" or organic, rather than a perfect square spiral.

Instead of always turning 90 degrees, make the turn angle change slightly with each iteration.

### Hint

<details>
  <summary>Stuck on Step 3? Click for a hint!</summary>

  *   You'll still have your `for` loop and the `t.forward(something * i)` line.
  *   The `t.left()` command is where the change happens.
  *   Instead of `t.left(90)`, try `t.left(90 + some_small_change)`.
  *   This `some_small_change` can also depend on your loop variable `i`. For example, you could add `i / 25` to 90. This means the angle change itself changes slightly with each step.
  *   Experiment with the amount you add or subtract from the base angle.

</details>

### Solution

<details>
  <summary>Ready to check your answer for Step 3? Click to reveal!</summary>

```python
import turtle
import math

s = turtle.Screen()
t = turtle.Turtle()

t.speed(10) # Set to 0 for fastest if desired, or 10 for fast

# Loop a sufficient number of times to see the pattern
for i in range(100): # Increased iterations to see the effect better
    t.forward(10 * i)   # Increasing forward distance
    t.left(90 + i / 25) # Base 90-degree turn, plus a small increasing change

turtle.done()
```

**Explanation:**
*   The `for i in range(100):` loop runs more times to make the pattern more prominent.
*   `t.forward(10 * i)` continues the outward spiral, possibly with a larger step multiplier.
*   `t.left(90 + i / 25)`:
    *   The base turn is still 90 degrees.
    *   `i / 25` is a small value that increases as `i` increases.
    *   So, the first few turns will be slightly more than 90 degrees (e.g., `90 + 0/25 = 90`, `90 + 1/25 = 90.04`, `90 + 2/25 = 90.08`, etc.).
    *   This slight, cumulative change in the turn angle causes the spiral to deviate from a perfect square shape, creating a "jagged" or curved effect over time.

</details>

---

## Step 4: Drawing a Spiraling Octagon Shape

### Problem

Modify your code from Step 3. Instead of a jagged square-like spiral, try to make the turtle draw a shape that resembles an octagon (8 sides) while still spiraling outwards and having a slightly changing angle.

The main difference between a square and an octagon is the angle of the turns.

### Hint

<details>
  <summary>Stuck on Step 4? Click for a hint!</summary>

  *   An octagon has 8 equal sides and 8 equal angles. The exterior angle of a regular polygon is `360 / number_of_sides`. For an octagon, what would this angle be?
  *   You only need to change one primary number in your `t.left()` command from the previous step to get the basic octagon turn.
  *   You can keep the `+ i / 25` part if you want the spiraling octagon to also have that slightly "organic" or jagged feel as it expands.

</details>

### Solution

<details>
  <summary>Ready to check your answer for Step 4? Click to reveal!</summary>

```python
import turtle
import math

s = turtle.Screen()
t = turtle.Turtle()

t.speed(10) # Or t.speed(0) for fastest

# Loop many times to see the octagonal spiral
for i in range(100): # Or more, e.g., 150-200, for a larger pattern
    t.forward(5 * i)     # Spiraling outwards, adjust '5' for spiral tightness
    t.left(45 + i / 25)  # Base turn for an octagon is 360/8 = 45 degrees

turtle.done()
```

**Explanation:**
*   The core logic of spiraling outwards (`t.forward(5 * i)`) and having a slightly varying angle (`+ i / 25`) remains similar.
*   The key change is `t.left(45 + i / 25)`:
    *   A regular octagon has 8 sides. To turn from one side to the next, the turtle needs to turn by an exterior angle of `360 / 8 = 45` degrees.
    *   So, the base turn angle is now `45` degrees.
    *   The `+ i / 25` part still adds a small, cumulative change to this base angle, making the octagonal spiral also look a bit "organic" or less rigidly geometric as it expands. If you wanted a more perfect octagonal spiral, you might omit the `+ i / 25` or make it much smaller.

</details>

---

## You Finished!

You've practiced:
*   Importing and using the `turtle` module for graphics.
*   Setting up the `Screen` and `Turtle` objects.
*   Controlling the turtle's speed using `t.speed()`.
*   Moving the turtle with `t.forward()` and turning it with `t.left()`.
*   Using `for` loops with `range()` to repeat drawing commands and create patterns.
*   Using the loop variable within the loop to dynamically change drawing parameters like distance (`t.forward(value * i)`).
*   Modifying turn angles within a loop to change the shape of paths and spirals (`t.left(base_angle + i / factor)`).
*   Understanding how changing the base turn angle affects the fundamental shape being drawn (e.g., 90 degrees for squares, 45 degrees for octagons).
*   Keeping the turtle graphics window open using `turtle.done()`.
---
</file>

<file path="activities/2025-05-17/stars-in-the-sky.md">
# Python Homework: Turtle Graphics - Stars in the Sky

Follow the steps below. For each step:
1.  **Read the problem carefully.**
2.  **Try to write the Python code yourself in VS Code.**
3.  **If you get stuck, open the "Hint" section.**
4.  **Once you think you have a solution or want to check your work, open the "Solution" section.**
5.  **Make sure your code works by running it!**

---

## Initial Setup

For all steps in this homework, you'll start with the following basic Python code. Make sure you have this at the beginning of your Python file. You'll add your drawing code for each step where indicated.

```python
import turtle
import random # You'll need this for a later step!

s = turtle.Screen()
t = turtle.Turtle()

# Set up the drawing environment
s.bgcolor("black")    # Make the screen background black
t.color("yellow")     # Set the turtle's pen and fill color to yellow
t.speed(10)           # Set turtle speed (0 is fastest, 10 is fast)

# Your drawing code for each step will go here

turtle.done() # Keeps the turtle window open until you close it
```
Remember to place the code for each step *before* the `turtle.done()` line.

---

## Step 1: Drawing a Single Star

### Problem

Your first task is to make the turtle draw a single, five-pointed star. The screen background should already be black, and the star's outline should be yellow (as per the initial setup). Do not fill the star with color yet.

Your turtle should start at its default position and orientation.

### Hint

<details>
  <summary>Stuck on Step 1? Click for a hint!</summary>

  *   To draw a star, you'll need a `for` loop that repeats 5 times (for the 5 points of the star).
  *   Inside the loop, the turtle needs to move forward to draw a line, and then turn.
  *   The command `t.forward(amount)` will draw a side of the star. You can choose a `star_size` for this (e.g., `50`).
  *   The command `t.right(angle)` will turn the turtle. The angle for a 5-pointed star is 144 degrees.
  *   Ensure `s.bgcolor("black")` and `t.color("yellow")` are set from the initial setup.

</details>

### Solution

<details>
  <summary>Ready to check your answer for Step 1? Click to reveal!</summary>

```python
import turtle
import random

s = turtle.Screen()
t = turtle.Turtle()

s.bgcolor("black") # Matches turtle.bgcolor("black") from snippet
t.color("yellow")
t.speed(10)

star_size = 50

for i in range(5):
    t.forward(star_size)
    t.right(144)

turtle.done()
```

**Explanation:**
*   `import turtle` and `import random` load the necessary libraries.
*   `s = turtle.Screen()` and `t = turtle.Turtle()` set up our drawing window and turtle.
*   `s.bgcolor("black")` sets the background color.
*   `t.color("yellow")` sets the turtle's drawing color.
*   `t.speed(10)` sets the drawing speed.
*   `star_size = 50` defines how long each segment of the star will be.
*   The `for i in range(5):` loop runs five times.
*   `t.forward(star_size)` moves the turtle forward, drawing one of the star's lines.
*   `t.right(144)` turns the turtle 144 degrees to the right. Repeating this sequence five times creates a five-pointed star.
*   `turtle.done()` keeps the window open.

</details>

---

## Step 2: Filling the Star

### Problem

Modify your code from Step 1. Now, in addition to drawing the star, fill its "limbs" (the inside of the star) with yellow color.

### Hint

<details>
  <summary>Stuck on Step 2? Click for a hint!</summary>

  *   The `turtle` library provides commands to control filling shapes.
  *   You need to tell the turtle when to `t.begin_fill()` before you start drawing the shape you want to fill.
  *   After you have finished drawing all the lines of the star (i.e., after your loop completes), you tell the turtle to `t.end_fill()`.
  *   The `t.color("yellow")` command from the initial setup should already handle setting the fill color to yellow.

</details>

### Solution

<details>
  <summary>Ready to check your answer for Step 2? Click to reveal!</summary>

```python
import turtle
import random

s = turtle.Screen()
t = turtle.Turtle()

s.bgcolor("black")
t.color("yellow") # Sets both pen and fill color to yellow
t.speed(10)

star_size = 50

t.begin_fill() # Start filling before drawing the star
for i in range(5):
    t.forward(star_size)
    t.right(144)
t.end_fill()   # End filling after the star is drawn

turtle.done()
```

**Explanation:**
*   The code is very similar to Step 1.
*   `t.begin_fill()`: This command is placed *before* the loop that draws the star. It tells the turtle to start recording the path for a filled shape.
*   The `for` loop draws the star as before.
*   `t.end_fill()`: This command is placed *after* the loop. It tells the turtle to complete the fill operation, coloring the area enclosed by the path drawn since `t.begin_fill()`. Since `t.color("yellow")` was used, the fill color is yellow.

</details>

---

## Step 3: Drawing Three Stars in a Row

### Problem

Modify your code from Step 2. Instead of one star, draw three identical filled yellow stars in a horizontal row. After drawing each star, you'll need to move the turtle to a new position to draw the next star, without leaving a trail during the move.

### Hint

<details>
  <summary>Stuck on Step 3? Click for a hint!</summary>

  *   You'll need an outer `for` loop that runs 3 times (once for each star).
  *   Inside this outer loop, you'll include the code to draw a single filled star (the `t.begin_fill()`, the inner loop for star points, and `t.end_fill()`).
  *   To move the turtle without drawing a line, use `t.penup()`.
  *   After lifting the pen, move the turtle to the starting position for the next star (e.g., `t.forward(some_distance)`).
  *   Then, use `t.pendown()` before you start drawing the next star.
  

</details>

### Solution

<details>
  <summary>Ready to check your answer for Step 3? Click to reveal!</summary>

```python
import turtle
import random

s = turtle.Screen()
t = turtle.Turtle()

s.bgcolor("black")
t.color("yellow")
t.speed(10)

star_size = 50

# Outer loop for drawing three stars
for i in range(3):
    # Draw one filled star
    t.begin_fill()
    for j in range(5): # Inner loop for the 5 points of a star
        t.forward(star_size)
        t.right(144)
    t.end_fill()

    # Move to the next star's position
    t.penup()
    t.forward(100) # Move forward to create space
    t.pendown()

turtle.done()
```

**Explanation:**
*   We introduce an outer loop: `for i in range(3):`. This loop will execute its contents three times.
*   Inside this outer loop, the code for drawing one filled star (from Step 2) is placed.
*   `t.begin_fill()` and `t.end_fill()` are inside the outer loop, so each star is individually filled.
*   After a star is drawn and filled, `t.penup()` lifts the pen.
*   `t.forward(100)` moves the turtle to the right by `100` units.
*   `t.pendown()` puts the pen back down, ready to draw the next star. This movement occurs after every star, including the last one.

</details>

---

## Step 4: Drawing Five Randomly Placed Stars

### Problem

Now, let's make things more dynamic! Modify your code to draw **five** filled yellow stars. Each star should appear at a somewhat random position on the screen. The stars should still be yellow on a black background.

### Hint

<details>
  <summary>Stuck on Step 4? Click for a hint!</summary>

  *   You'll need the `random` module. Make sure `import random` is at the top of your script.
  *   The function `random.randint(a, b)` returns a random integer between `a` and `b` (inclusive).
  *   Your outer loop should run 5 times for five stars.
  *   After drawing each star (and using `t.end_fill()`), you need to:
      1.  Lift the pen: `t.penup()`.
      2.  Generate random `dx` (change in x) and `dy` (change in y) values (e.g., `random.randint(-100, 100)`).
      3.  Move the turtle using these relative changes: `t.forward(dx)`, `t.left(90)`, `t.forward(dy)`, and then `t.right(90)` to restore the turtle's orientation for drawing the next star.
      4.  Put the pen down: `t.pendown()`.

</details>

### Solution

<details>
  <summary>Ready to check your answer for Step 4? Click to reveal!</summary>

```python
import turtle
import random

s = turtle.Screen()
t = turtle.Turtle()

s.bgcolor("black")
t.color("yellow")
t.speed(10)

# Initial positioning, as in the snippet
t.penup()
t.backward(200)
t.pendown()

star_size = 50

# Loop to draw five stars (as per problem description)
for i in range(5):
    # Draw one filled star
    t.begin_fill()
    for j in range(5): # Inner loop for the 5 points of a star
        t.forward(star_size)
        t.right(144)
    t.end_fill()

    # Prepare to move to a new random position for the next star
    t.penup()

    # Generate random changes in x and y direction
    dx = random.randint(-100, 100)
    dy = random.randint(-100, 100)

    # Move turtle by dx, then dy (relative to current position and orientation)
    # This sequence aims to move randomly while keeping star orientation consistent
    t.forward(dx)
    t.left(90)
    t.forward(dy)
    t.right(90) # Restores original orientation

    t.pendown() # Pen down ready for the next star

turtle.done()
```

**Explanation:**
*   The outer loop `for i in range(5):` runs five times to draw five stars, as requested by the problem.
*   The `t.penup(); t.backward(200); t.pendown();` lines before the loop provide an initial positioning.
*   Inside the loop, after a star is drawn and filled:
    *   `t.penup()` lifts the pen.
    *   `dx = random.randint(-100, 100)` and `dy = random.randint(-100, 100)` generate random values for movement.
    *   The sequence `t.forward(dx)`, `t.left(90)`, `t.forward(dy)`, `t.right(90)` moves the turtle relatively. The `t.right(90)` is important to reset the turtle's orientation so the next star is drawn upright.
    *   `t.pendown()` puts the pen down, ready for the next star.

</details>

---

## You Finished!

You've practiced:
*   Importing and using the `turtle` module for graphics.
*   Setting up the `Screen` and `Turtle` objects.
*   Controlling screen properties like `bgcolor`.
*   Controlling turtle properties like `color` (for pen and fill) and `speed`.
*   Drawing shapes using `t.forward()` and `t.right()`.
*   Using `for` loops to repeat drawing commands and create shapes like stars.
*   Using nested `for` loops.
*   Filling shapes with color using `t.begin_fill()` and `t.end_fill()`.
*   Moving the turtle without drawing using `t.penup()` and `t.pendown()`.
*   Importing and using the `random` module, specifically `random.randint()`, to add unpredictability.
*   Using random numbers to determine relative movements for drawn elements.
*   Keeping the turtle graphics window open using `turtle.done()`.
</file>

<file path=".gitignore">
/prompting/
</file>

<file path="activities/2025-05-03/age-chart.md">
# Python Homework: Loops and Age Categories

Follow the steps below. For each step:
1.  **Read the problem carefully.**
2.  **Try to write the Python code yourself in VS Code.**
3.  **If you get stuck, open the "Hint" section.**
4.  **Once you think you have a solution or want to check your work, open the "Solution" section.**
5.  **Make sure your code works by running it!**

---

## Step 1: Looping Through Ages

### Problem

Let's start by just getting a list of ages. Write a `for` loop using the `range()` function to print numbers from 1 up to and including 29. Each number should be on a new line.

Here's what your program should output:

```
1
2
...
29
```

### Hint

<details>
  <summary>Stuck on Step 1? Click for a hint!</summary>

  Remember that `range()` can take two arguments: `range(start, stop)`. The starting number is included, but the `stop` number is *not* included. If you want to include 29, what number should the `stop` be?

  Your loop structure will be `for age in range(..., ...):`. What should go inside the `range()`? And what should you `print()` inside the loop?

</details>

### Solution

<details>
  <summary>Ready to check your answer for Step 1? Click to reveal!</summary>

```python
for age in range(1, 30):
    print(age)
```

**Explanation:**
*   `for age in range(1, 30):` sets up a loop that will run for numbers starting from 1 up to (but not including) 30. The variable `age` will take on the values 1, 2, ..., up to 29 in each iteration.
*   `print(age)` inside the loop prints the current value of `age`. Since this is inside the loop, it prints `age` every time the loop runs.

</details>

---

## Step 2: Basic Age Categories

### Problem

Now, let's use conditional logic inside the loop. Using the same loop that iterates through ages 1 to 29, add an `if` statement:
*   If the current `age` is less than 18, print the age followed by the word " minor" on the same line.

Ages 18 and over should not print anything in this step.

Your output should look something like this (it stops at age 17):

```
1 minor
2 minor
...
17 minor
```

### Hint

<details>
  <summary>Stuck on Step 2? Click for a hint!</summary>

  You need an `if` statement *inside* your `for` loop. The condition for the `if` should be `age < 18`.

  The `print()` statement that prints the age and " minor" should only happen *if* the `if` condition is true. Make sure it's indented under the `if` statement.

  Remember to convert the `age` (which is a number) to a string using `str()` before combining it with other strings using the `+` operator.

</details>

### Solution

<details>
  <summary>Ready to check your answer for Step 2? Click to reveal!</summary>

```python
for age in range(1, 30):
    if age < 18:
        print(str(age) + " minor")
```

**Explanation:**
*   `for age in range(1, 30):` sets up the loop for ages 1 through 29.
*   `if age < 18:` checks if the current value of `age` is less than 18.
*   `print(str(age) + " minor")` is indented under the `if`. This line only runs when the `age` is indeed less than 18. It converts the age to a string and concatenates it with `" minor"`.

</details>

---

## Step 3: Adding Another Category

### Problem

Let's complete the basic categories. Modify your code from Step 2. Keep the loop iterating through ages 1 to 29, and keep the logic for printing " minor". Now, add a *separate* `if` statement:
*   If the current `age` is 18 or greater, print the age followed by the word " adult" on the same line.

Your output should now cover all ages from 1 to 29, with each age labeled as either " minor" or " adult":

```
1 minor
...
17 minor
18 adult
19 adult
...
29 adult
```

### Hint

<details>
  <summary>Stuck on Step 3? Click for a hint!</summary>

  You should have *two* `if` statements inside your `for` loop. Both `if` statements should be at the same level of indentation (indented relative to the `for` loop, but *not* indented relative to each other).

  The first `if` checks `age < 18`. The second `if` checks `age >= 18`.

</details>

### Solution

<details>
  <summary>Ready to check your answer for Step 3? Click to reveal!</summary>

```python
for age in range(1, 30):
    if age < 18:
        print(str(age) + " minor")
    if age >= 18: # This is a separate if statement
        print(str(age) + " adult")
```

**Explanation:**
*   The code is the same as Step 2, but we added a second `if` statement at the same level of indentation as the first one.
*   `if age < 18:` handles the "minor" case.
*   `if age >= 18:` handles the "adult" case. Since these are separate `if` statements, Python checks both conditions for every `age` in the loop. For ages less than 18, the first `if` is true. For ages 18 and over, the second `if` is true. (Note: Using `if`/`elif` would be more efficient here, but this step specifically demonstrates using multiple independent `if` checks as shown in your example code).

</details>

---

## Step 4: More Granular Age Categories

### Problem

Let's get more specific with the age categories! Modify your code from Step 3 to implement the following categories based on the `age` (still looping from 1 to 29):
*   If age is less than or equal to 3, print `age` followed by " toddler".
*   If age is greater than 3 AND less than or equal to 8, print `age` followed by " child".
*   If age is greater than 8 AND less than or equal to 12, print `age` followed by " tween".
*   If age is greater than 12 AND less than or equal to 17, print `age` followed by " minor".
*   If age is greater than or equal to 18, print `age` followed by " adult".

You will need multiple `if` statements again, some using the `and` keyword to check ranges.

Your output should now categorize every age from 1 to 29 according to these specific rules:

```
1 toddler
2 toddler
3 toddler
4 child
...
8 child
9 tween
...
12 tween
13 minor
...
17 minor
18 adult
...
29 adult
```

### Hint

<details>
  <summary>Stuck on Step 4? Click for a hint!</summary>

  You'll need one `if` statement for each category. All of these `if` statements should be inside the `for` loop and at the same level of indentation.

  For the conditions that check a range (like "between 3 and 8"), you will use the `and` keyword to combine two comparisons, like `3 < age and age <= 8`.

  Make sure you print the age and the correct category string for each successful `if` condition.

</details>

### Solution

<details>
  <summary>Ready to check your answer for Step 4? Click to reveal!</summary>

```python
for age in range(1, 30):
    # if age is less than or equal to 3
    if age <= 3:
        print(str(age) + " toddler")

    # if age is between 3 and 8 (inclusive)
    if 3 < age and age <= 8:
        print(str(age) + " child")

    # if age is between 8 and 12 (inclusive)
    if 8 < age and age <= 12:
        print(str(age) + " tween")

    # if age is between 12 and 17 (inclusive)
    if 12 < age and age <= 17:
        print(str(age) + " minor")

    # if age is greater than or equal to 18
    if age >= 18:
        print(str(age) + " adult")
```

**Explanation:**
*   The loop `for age in range(1, 30):` iterates through each age from 1 to 29.
*   Inside the loop, there are five separate `if` statements, one for each age category.
*   Each `if` statement checks a specific condition (or range of conditions using `and`).
*   If a condition is true for the current `age`, the corresponding `print()` statement (indented under that `if`) executes, printing the age followed by the category label. Since these are all separate `if` statements, Python checks *each* condition for *every* age, even though an age can only fall into one category. (Again, `if`/`elif`/`else` would be more efficient, but this matches the provided code structure).

Here's an alternative solution using `elif`:

```python
for age in range(1, 30):
    if age <= 3:
        print(str(age) + " toddler")
    elif age <= 8:
        print(str(age) + " child")
    elif age <= 12:
        print(str(age) + " tween")
    elif age <= 17:
        print(str(age) + " minor")
    else:
        # then it must be an adult
        print(str(age) + " adult")
```

</details>

---

## You Finished!

You've practiced:
*   Using `for` loops with `range(start, stop)` to iterate through a sequence of numbers.
*   Using the loop variable (`age`) within the loop.
*   Putting `if` statements inside a loop to perform actions conditionally for each item.
*   Using comparison operators (`<`, `<=`, `>`, `>=`).
*   Using the logical operator `and` to combine multiple conditions in an `if` statement.

Well done!
---
</file>

<file path="activities/2025-05-03/cheatsheet.md">
Read this cheat sheet after you've done all the homework so it doesn't spoil the fun.

---

# Python Homework Cheat Sheet: Loops & Conditionals

This sheet summarizes useful Python concepts covered in the homework exercises.

- [Python Homework Cheat Sheet: Loops \& Conditionals](#python-homework-cheat-sheet-loops--conditionals)
  - [1. `for` Loops with `range()`](#1-for-loops-with-range)
  - [2. Using the Loop Variable](#2-using-the-loop-variable)
  - [3. `if` Statements inside Loops](#3-if-statements-inside-loops)
  - [4. Comparison Operators](#4-comparison-operators)
  - [5. Logical Operator (`and`)](#5-logical-operator-and)
  - [6. Getting User Input (`input()`)](#6-getting-user-input-input)
  - [7. Type Conversion (`int()`, `str()`)](#7-type-conversion-int-str)
  - [8. Performing Calculations](#8-performing-calculations)


---

## 1. `for` Loops with `range()`

**Explanation:** The `for` loop is used to iterate over a sequence. `range()` generates a sequence of numbers, often used to repeat an action a specific number of times.
*   `range(stop)`: Generates numbers from 0 up to (but not including) `stop`.
*   `range(start, stop)`: Generates numbers from `start` up to (but not including) `stop`.

**Code Example:**

```python
# Loop from 0 to 4
for i in range(5):
    print(i)

# Loop from 1 to 10
for num in range(1, 11):
    print(num)
```

**Output:**

```
0
1
2
3
4
1
2
3
4
5
6
7
8
9
10
```

---

## 2. Using the Loop Variable

**Explanation:** Inside a `for` loop, the variable you define (like `i` or `num`) holds the current item from the sequence being iterated over. You can use this variable in calculations, print statements, or conditions.

**Code Example:**

```python
# Print age categories using the 'age' variable
for age in range(1, 6): # Ages 1 through 5
    if age <= 3:
        print(str(age) + " toddler")
    else:
        print(str(age) + " child")
```

**Output:**

```
1 toddler
2 toddler
3 toddler
4 child
5 child
```

---

## 3. `if` Statements inside Loops

**Explanation:** Placing `if` statements inside a loop allows you to perform actions conditionally for *each* item or iteration. You decide whether to execute certain code based on the current value of the loop variable or other conditions.

**Code Example:**

```python
# Print numbers, but skip 4
for num in range(1, 6): # Numbers 1 through 5
    if num != 4:
        print("Current number: " + str(num))
    else:
        print("Skipped number: " + str(num)) # Or just 'print("unlucky")'
```

**Output:**

```
Current number: 1
Current number: 2
Current number: 3
Skipped number: 4
Current number: 5
```

---

## 4. Comparison Operators

**Explanation:** Used in `if` (or `elif`/`else`) conditions to compare values.

**Common Operators:**
*   `<` (less than)
*   `<=` (less than or equal to)
*   `>` (greater than)
*   `>=` (greater than or equal to)
*   `==` (equal to)
*   `!=` (not equal to)

**Code Example:**

```python
my_age = 20

if my_age >= 18:
    print("You are an adult.")
if my_age != 21:
    print("You are not 21.")
```

**Output:**

```
You are an adult.
You are not 21.
```

---

## 5. Logical Operator (`and`)

**Explanation:** Used to combine multiple conditions. The condition joined by `and` is only true if *both* individual conditions are true.

**Code Example:**

```python
score = 75

# Check if score is between 70 and 80 (inclusive)
if score >= 70 and score <= 80:
    print("Score is in the 70s.")
```

**Output:**

```
Score is in the 70s.
```

---

## 6. Getting User Input (`input()`)

**Explanation:** The `input()` function pauses the program and waits for the user to type something and press Enter. It *always* returns the user's input as a string.

**Code Example:**

```python
name = input("Enter your name: ")
print("Hello, " + name + "!")
```

**Output (Example Interaction):**

```
Enter your name: Alice
Hello, Alice!
```

---

## 7. Type Conversion (`int()`, `str()`)

**Explanation:** Often you need to convert data from one type to another. `int()` converts a string (or other compatible type) to an integer. `str()` converts a number (or other type) to a string so you can concatenate it with other strings.

**Code Example:**

```python
# Get user input and convert to integer for math
user_num_str = input("Enter a number: ")
user_num_int = int(user_num_str)

# Use the integer in a calculation
result = user_num_int * 2

# Convert numbers back to string for printing
print("Twice your number is: " + str(result))
```

**Output (Example Interaction):**

```
Enter a number: 15
Twice your number is: 30
```

---

## 8. Performing Calculations

**Explanation:** Standard arithmetic operations (`+`, `-`, `*`, `/`, etc.) can be performed directly on numbers (integers or floats). Results can be stored in variables and used later.

**Code Example:**

```python
fixed_num = 7
for multiplier in range(1, 4): # Loop 1, 2, 3
    product = fixed_num * multiplier
    print(str(fixed_num) + " * " + str(multiplier) + " = " + str(product))
```

**Output:**

```
7 * 1 = 7
7 * 2 = 14
7 * 3 = 21
```

---
</file>

<file path="activities/2025-05-03/homework.md">
I've prepared two problems for you.

The first one relates to making a multiplication table. Open it by clicking [Multiplication Table Homework](./multiplication-table.md).

After you're done with that one, go on to the next one by clicking [Age Chart Homework](./age-chart.md)

Once all homework is done, you can see the cheatsheet containing concepts from the activities you've just done.

Good luck!
</file>

<file path="activities/2025-05-03/multiplication-table.md">
# Python Homework: Loops and Conditionals

Follow the steps below. For each step:
1.  **Read the problem carefully.**
2.  **Try to write the Python code yourself in VS Code.**
3.  **If you get stuck, open the "Hint" section.**
4.  **Once you think you have a solution or want to check your work, open the "Solution" section.**
5.  **Make sure your code works by running it!**

---

## Step 1: Counting with a Loop

### Problem

Your first task is simple: Print the numbers from 0 up to and including 10, with each number on a new line. You *must* use a `for` loop and the `range()` function.

Here's what your program should output mate.

```
0
1
...
9
10
```

### Hint

<details>
  <summary>Stuck on Step 1? Click for a hint!</summary>

  Remember that `range(x)` generates numbers starting from 0 up to (but not including) `x`. If you want to include 10, what number should `x` be?

  Your loop structure will look something like `for number in range(...):`. What should go inside the `range()`? And what should you `print()` inside the loop?

</details>

### Solution

<details>
  <summary>Ready to check your answer for Step 1? Click to reveal!</summary>

```python
for num in range(11):
    print(num)
```

**Explanation:**
*   `for num in range(11):` sets up a loop that will run 11 times. The variable `num` will take on the values 0, 1, 2, ..., up to 10 in each iteration.
*   `print(num)` inside the loop prints the current value of `num`. Since this is inside the loop, it prints `num` every time the loop runs.

</details>

---

## Step 2: Using the Loop Variable

### Problem

Now, let's use the number (`num` variable) from the loop in the output to make a multiplication table. Write a loop that prints a 7x multiplication table for numbers 1 through 10. The output for each line should look like this:

```
7 * 1 =
7 * 2 =
...
7 * 10 =
```

Notice that we are starting from 1 this time, not 0. And we don't care about the results of the multiplication problems yet.

### Hint

<details>
  <summary>Stuck on Step 2? Click for a hint!</summary>

  How can you make `range()` start at 1 instead of 0? Remember that `range()` can take two arguments: `range(start, stop)`. The `stop` value is *not* included.

  Inside the loop, you'll need to print a string. This string should combine the fixed text `"7 * "` with the current number from your loop and `" = "`. You'll need to convert the loop number to a string to combine them using the `+` operator.

</details>

### Solution

<details>
  <summary>Ready to check your answer for Step 2? Click to reveal!</summary>

```python
for num in range(1, 11):
    print("7 * " + str(num) + " = ")
```

**Explanation:**
*   `for num in range(1, 11):` sets up a loop that runs for numbers starting from 1 up to (but not including) 11. So `num` will be 1, 2, ..., 10.
*   `print("7 * " + str(num) + " = ")` concatenates three strings: `"7 * "`, the string representation of the current number (`str(num)`), and `" = "`. This combined string is then printed.

</details>

---

## Step 3: Doing Math Inside the Loop

### Problem

Let's complete the 7 times table. Modify your code from Step 2 so that it calculates and prints the actual answer for each multiplication problem. The output should look like this:

```
7 * 1 = 7
7 * 2 = 14
...
7 * 10 = 70
```

### Hint

<details>
  <summary>Stuck on Step 3? Click for a hint!</summary>

  Inside the loop, before you print, you need to calculate `7 * num`. You can store the result of this calculation in a variable, like `answer`.

  Then, when you print, you'll need to add this `answer` to your string. Remember that `answer` will be a number, so you'll need to convert it to a string using `str()` before you can concatenate it with the other string parts.

</details>

### Solution

<details>
  <summary>Ready to check your answer for Step 3? Click to reveal!</summary>

```python
for num in range(1, 11):
    answer = 7 * num
    print("7 * " + str(num) + " = " + str(answer))
```

**Explanation:**
*   `for num in range(1, 11):` is the same loop as before (numbers 1 through 10).
*   `answer = 7 * num` performs the multiplication using the fixed number 7 and the current loop number `num`. The result is stored in the `answer` variable.
*   `print("7 * " + str(num) + " = " + str(answer))` concatenates the string parts `"7 * "`, the string version of `num`, `" = "`, and the string version of `answer`. This forms the complete output line.

</details>

---

## Step 4: Dynamic Tables with User Input

### Problem

The 7 times table is cool, but what about other tables? Modify your code so that it first asks the user to "Give me a number". Then, print the multiplication table (from 1 to 10) for the number the user entered.

It should look like this:

```
5
5 * 1 = 5
5 * 2 = 10
5 * 3 = 15
5 * 4 = 20
5 * 5 = 25
5 * 6 = 30
5 * 7 = 35
5 * 8 = 40
5 * 9 = 45
5 * 10 = 50
```

### Hint

<details>
  <summary>Stuck on Step 4? Click for a hint!</summary>

  How do you get input from the user? The `input()` function is what you need.

  Remember that `input()` *always* returns a string. For calculations, you need a number (an integer). How do you convert a string to an integer? Use `int()`.

  Store the user's number in a variable (e.g., `main_number`) *before* the loop starts. Then, inside the loop, use this `main_number` variable in your calculation (`main_number * num`) and in your `print()` statement.

</details>

### Solution

<details>
  <summary>Ready to check your answer for Step 4? Click to reveal!</summary>

```python
print("Give me a number")
main_number = input()
main_number = int(main_number)

for num in range(1, 11):
    answer = main_number * num
    print(str(main_number) + " * " + str(num) + " = " + str(answer))
```

**Explanation:**
*   `print("Give me a number")` prompts the user.
*   `main_number = input()` reads the user's input (as a string) and stores it in the `main_number` variable.
*   `main_number = int(main_number)` converts the string input into an integer, overwriting the string value in `main_number`. Now `main_number` is a number we can use in calculations.
*   The loop `for num in range(1, 11):` is the same as before.
*   `answer = main_number * num` performs the multiplication using the user's number and the current loop number.
*   `print(...)` constructs the output string, making sure to convert `main_number`, `num`, and `answer` to strings where necessary.

</details>

---

## Step 5: Using `if` Inside the Loop

### Problem

Let's add a condition! Modify your code from Step 4. It should still ask for a number and print its multiplication table from 1 to 10. However, **skip the line where the multiplier (`num`) is 4.** Because the East Asians considers it unlucky!

If the user enters 5, the output should look like this (notice the missing line for 5 * 4):

```
Give me a number
5
5 * 1 = 5
5 * 2 = 10
5 * 3 = 15
unlucky
5 * 5 = 25
5 * 6 = 30
5 * 7 = 35
5 * 8 = 40
5 * 9 = 45
5 * 10 = 50
```

### Hint

<details>
  <summary>Stuck on Step 5? Click for a hint!</summary>

  You need to decide *whether* to print a line *inside* the loop. This sounds like a job for an `if` statement!

  The condition for your `if` statement should check if the current loop number (`num`) is *not* equal to 4. How do you check for "not equal"? The operator is `!=`.

  The `print()` statement should only happen *if* the condition in your `if` statement is true. Make sure the `print()` statement is indented *inside* the `if` block.

</details>

### Solution

<details>
  <summary>Ready to check your answer for Step 5? Click to reveal!</summary>

```python
print("Give me a number")
main_number = input()
main_number = int(main_number)

for num in range(1, 11):
    answer = main_number * num
    if num != 4:
        print(str(main_number) + " * " + str(num) + " = " + str(answer))
    else:
        print("unlucky")
```

**Explanation:**
*   The code is the same as Step 4, but with an added `if` statement inside the loop.
*   `if num != 4:` checks if the current value of `num` is not equal to 4.
*   The `print(str(main_number) + ...)` line is indented under the `if` statement. This means that the `print(str(main_number) + ...)` command will only execute if the condition `num != 4` is true.

</details>

---

## You Finished!

You've practiced:
*   Using `for num in range(x)` and `for num in range(start, stop)`.
*   Using the loop variable (`num`) in calculations and `print()` statements.
*   Getting user input and converting it to a number.
*   Putting an `if` statement *inside* a loop to control which actions happen for each item in the loop.
</file>

<file path="readme.md">
- [Homework 2025-05-03](./activities/2025-05-03/homework.md)
</file>

</files>
